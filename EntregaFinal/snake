#include <iostream>
#include <conio.h>
#include <windows.h>
#include <chrono>

using namespace std;
using namespace std::chrono;

class Juego {
protected:
    bool gameOver;
    int height; // Dimensiones del mapa
    int width;
    int score;
    int speed; // Velocidad del juego
    enum eDirection { STOP = 0, LEFT, RIGHT, UP, DOWN }; // Mover la cabeza
    eDirection dir; // Dirección de la cabeza

    HANDLE hConsole;
    CHAR_INFO* buffer;
    COORD bufferSize;
    COORD characterPos;
    SMALL_RECT consoleWriteArea;

public:
    Juego() : gameOver(false), score(0), dir(STOP), height(20), width(20), speed(100) {
        hConsole = GetStdHandle(STD_OUTPUT_HANDLE);
        bufferSize = { (short)(width + 2), (short)(height + 2) };
        buffer = new CHAR_INFO[bufferSize.X * bufferSize.Y];
        characterPos = { 0, 0 };
        consoleWriteArea = { 0, 0, bufferSize.X - 1, bufferSize.Y - 1 };
    }

    ~Juego() {
        delete[] buffer;
    }

    virtual void Setup() = 0;
    virtual void Draw() = 0;
    virtual void Input() = 0;
    virtual void Logic() = 0;
    virtual void run() = 0;

    void DrawGameOver() {
        std::string message = "GAME OVER";
        int startX = (width + 2) / 2 - message.size() / 2;
        int startY = (height + 2) / 2;

        for (int i = 0; i < message.size(); i++) {
            buffer[startY * (width + 2) + startX + i].Char.AsciiChar = message[i];
            buffer[startY * (width + 2) + startX + i].Attributes = 0x0C; // Red text
        }

        WriteConsoleOutputA(hConsole, buffer, bufferSize, characterPos, &consoleWriteArea);
    }

    bool isGameOver() const { return gameOver; }
    void setGameOver(bool state) { gameOver = state; }
    void setDirection(eDirection d) { dir = d; }
    eDirection getDirection() const { return dir; }
};

class Serpiente : public Juego {
protected:
    int x, y; // Coordenadas de la cabeza
    int tailX[100], tailY[100]; // Array para el cuerpo de la serpiente (almacenar sus posiciones)
    int nTail; // tamaño de la serpiente

public:
    Serpiente() : x(0), y(0), nTail(0) {}

    void Setup() override {
        gameOver = false;
        dir = STOP;
        x = width / 2;
        y = height / 2;
        score = 0;
        nTail = 0;
    }

    void Draw() override {
        for (int i = 0; i < bufferSize.X * bufferSize.Y; i++) {
            buffer[i].Char.AsciiChar = ' ';
            buffer[i].Attributes = 0x07;
        }

        for (int i = 0; i < width + 2; i++) { // borde superior
            buffer[i].Char.AsciiChar = '-';
        }

        for (int i = 1; i <= height; i++) {
            buffer[i * (width + 2)].Char.AsciiChar = '|'; // borde izquierdo
            buffer[(i + 1) * (width + 2) - 1].Char.AsciiChar = '|'; // borde derecho
        }

        for (int i = 0; i < width + 2; i++) { // borde inferior
            buffer[(height + 1) * (width + 2) + i].Char.AsciiChar = '-';
        }

        buffer[(y + 1) * (width + 2) + (x + 1)].Char.AsciiChar = '0'; // dibujar cabeza de la serpiente

        for (int i = 0; i < nTail; i++) {
            buffer[(tailY[i] + 1) * (width + 2) + (tailX[i] + 1)].Char.AsciiChar = 'o';
        }

        for (int i = 0; i < bufferSize.X * bufferSize.Y; i++) {
            buffer[i].Attributes = 0x07;
        }

        WriteConsoleOutputA(hConsole, buffer, bufferSize, characterPos, &consoleWriteArea);

        // Mostrar puntuación
        SetConsoleCursorPosition(hConsole, { 0, (short)(height + 2) });
        cout << "Score: " << score << endl;
    }

    void Input() override {
        if (_kbhit()) {
            switch (_getch()) {
            case 'a':
                if (dir != RIGHT) dir = LEFT;
                break;
            case 'd':
                if (dir != LEFT) dir = RIGHT;
                break;
            case 'w':
                if (dir != DOWN) dir = UP;
                break;
            case 's':
                if (dir != UP) dir = DOWN;
                break;
            case 'x':
                gameOver = true;
                break;
            }
        }
    }

    void Logic() override {
        int prevX = tailX[0], prevY = tailY[0];
        int prev2X, prev2Y;
        tailX[0] = x;
        tailY[0] = y;

        for (int i = 1; i < nTail; i++) {
            prev2X = tailX[i];
            prev2Y = tailY[i];
            tailX[i] = prevX;
            tailY[i] = prevY;
            prevX = prev2X;
            prev2Y = prev2Y;
        }

        switch (dir) {
        case LEFT:
            x--;
            break;
        case RIGHT:
            x++;
            break;
        case UP:
            y--;
            break;
        case DOWN:
            y++;
            break;
        default:
            break;
        }

        // Wrap-around logic for the edges for easy difficulty
        if (width == 10 && height == 10) { // Only for easy difficulty
            if (x >= width) x = 0; else if (x < 0) x = width - 1;
            if (y >= height) y = 0; else if (y < 0) y = height - 1;
        }
        else {
            // Standard collision with walls for medium and hard difficulty
            if (x >= width || x < 0 || y >= height || y < 0)
                gameOver = true;
        }

        for (int i = 0; i < nTail; i++)
            if (tailX[i] == x && tailY[i] == y)
                gameOver = true;
    }

    void run() override {
        Setup();
        auto lastTime = steady_clock::now();
        while (!isGameOver()) {
            auto currentTime = steady_clock::now();
            auto elapsedTime = duration_cast<milliseconds>(currentTime - lastTime);
            if (elapsedTime.count() >= speed) {
                Input();
                Logic();
                Draw();
                lastTime = currentTime;
            }
            else {
                Input();
            }
        }
        DrawGameOver(); // Show game over message when the game ends
        Sleep(2000); // Wait for 2 seconds before returning to menu
    }
};

class Comida : public Serpiente {
protected:
    int fruitX, fruitY;

public:
    Comida() : fruitX(0), fruitY(0) {}

    void Setup() override {
        Serpiente::Setup();
        fruitX = rand() % width;
        fruitY = rand() % height;
    }

    void Draw() override {
        for (int i = 0; i < bufferSize.X * bufferSize.Y; i++) {
            buffer[i].Char.AsciiChar = ' ';
            buffer[i].Attributes = 0x07;
        }

        for (int i = 0; i < width + 2; i++) { // borde superior
            buffer[i].Char.AsciiChar = '-';
        }

        for (int i = 1; i <= height; i++) {
            buffer[i * (width + 2)].Char.AsciiChar = '|'; // borde izquierdo
            buffer[(i + 1) * (width + 2) - 1].Char.AsciiChar = '|'; // borde derecho
        }

        for (int i = 0; i < width + 2; i++) { // borde inferior
            buffer[(height + 1) * (width + 2) + i].Char.AsciiChar = '-';
        }

        buffer[(y + 1) * (width + 2) + (x + 1)].Char.AsciiChar = '0'; // dibujar cabeza de la serpiente

        for (int i = 0; i < nTail; i++) {
            buffer[(tailY[i] + 1) * (width + 2) + (tailX[i] + 1)].Char.AsciiChar = 'o';
        }

        buffer[(fruitY + 1) * (width + 2) + (fruitX + 1)].Char.AsciiChar = '*'; // dibujar fruta

        WriteConsoleOutputA(hConsole, buffer, bufferSize, characterPos, &consoleWriteArea);

        // Mostrar puntuación
        SetConsoleCursorPosition(hConsole, { 0, (short)(height + 2) });
        cout << "Score: " << score << endl;
    }

    void Logic() override {
        Serpiente::Logic();

        if (x == fruitX && y == fruitY) {
            score += 100;
            fruitX = rand() % width;
            fruitY = rand() % height;
            nTail++;
        }
    }
};

class Bonus : public Comida {
protected:
    int bonusX, bonusY;
    int boostX, boostY;

public:
    Bonus() : bonusX(0), bonusY(0), boostX(0), boostY(0) {}

    void Setup() override {
        Comida::Setup();
        bonusX = rand() % width;
        bonusY = rand() % height;
        boostX = rand() % width;
        boostY = rand() % height;
    }

    void Draw() override {
        for (int i = 0; i < bufferSize.X * bufferSize.Y; i++) {
            buffer[i].Char.AsciiChar = ' ';
            buffer[i].Attributes = 0x07;
        }

        for (int i = 0; i < width + 2; i++) { // borde superior
            buffer[i].Char.AsciiChar = '-';
        }

        for (int i = 1; i <= height; i++) {
            buffer[i * (width + 2)].Char.AsciiChar = '|'; // borde izquierdo
            buffer[(i + 1) * (width + 2) - 1].Char.AsciiChar = '|'; // borde derecho
        }

        for (int i = 0; i < width + 2; i++) { // borde inferior
            buffer[(height + 1) * (width + 2) + i].Char.AsciiChar = '-';
        }

        buffer[(y + 1) * (width + 2) + (x + 1)].Char.AsciiChar = '0'; // dibujar cabeza de la serpiente

        for (int i = 0; i < nTail; i++) {
            buffer[(tailY[i] + 1) * (width + 2) + (tailX[i] + 1)].Char.AsciiChar = 'o';
        }

        buffer[(fruitY + 1) * (width + 2) + (fruitX + 1)].Char.AsciiChar = '*'; // dibujar fruta
        buffer[(bonusY + 1) * (width + 2) + (bonusX + 1)].Char.AsciiChar = '+'; // dibujar bonus
        buffer[(boostY + 1) * (width + 2) + (boostX + 1)].Char.AsciiChar = '>'; // dibujar boost

        WriteConsoleOutputA(hConsole, buffer, bufferSize, characterPos, &consoleWriteArea);

        // Mostrar puntuación
        SetConsoleCursorPosition(hConsole, { 0, (short)(height + 2) });
        cout << "Score: " << score << endl;
    }

    void Logic() override {
        Comida::Logic();

        if (x == bonusX && y == bonusY) {
            score += 500;
            bonusX = rand() % width;
            bonusY = rand() % height;
            nTail++;
        }

        if (x == boostX && y == boostY) {
            // implementar función para ir más rápido
            boostX = rand() % width;
            boostY = rand() % height;
        }
    }
};

class DificultadFacil : public Comida {
public:
    void Setup() override {
        width = 10;
        height = 10;
        speed = 250;
        bufferSize = { (short)(width + 2), (short)(height + 2) };
        delete[] buffer;
        buffer = new CHAR_INFO[bufferSize.X * bufferSize.Y];
        consoleWriteArea = { 0, 0, bufferSize.X - 1, bufferSize.Y - 1 };
        Comida::Setup();
    }

    void run() override {
        Setup();
        auto lastTime = steady_clock::now();
        while (!isGameOver()) {
            auto currentTime = steady_clock::now();
            auto elapsedTime = duration_cast<milliseconds>(currentTime - lastTime);
            if (elapsedTime.count() >= speed) {
                Input();
                Logic();
                Draw();
                lastTime = currentTime;
            }
            else {
                Input();
            }
        }
        DrawGameOver(); // Show game over message when the game ends
        Sleep(2000); // Wait for 2 seconds before returning to menu
    }
};

class DificultadMedia : public Bonus {
public:
    void Setup() override {
        width = 20;
        height = 20;
        speed = 100;
        bufferSize = { (short)(width + 2), (short)(height + 2) };
        delete[] buffer;
        buffer = new CHAR_INFO[bufferSize.X * bufferSize.Y];
        consoleWriteArea = { 0, 0, bufferSize.X - 1, bufferSize.Y - 1 };
        Bonus::Setup();
    }

    void run() override {
        Setup();
        auto lastTime = steady_clock::now();
        while (!isGameOver()) {
            auto currentTime = steady_clock::now();
            auto elapsedTime = duration_cast<milliseconds>(currentTime - lastTime);
            if (elapsedTime.count() >= speed) {
                Input();
                Logic();
                Draw();
                lastTime = currentTime;
            }
            else {
                Input();
            }
        }
        DrawGameOver(); // Show game over message when the game ends
        Sleep(2000); // Wait for 2 seconds before returning to menu
    }
};

class DificultadDificil : public Bonus {
public:
    void Setup() override {
        width = 30;
        height = 30;
        speed = 50;
        bufferSize = { (short)(width + 2), (short)(height + 2) };
        delete[] buffer;
        buffer = new CHAR_INFO[bufferSize.X * bufferSize.Y];
        consoleWriteArea = { 0, 0, bufferSize.X - 1, bufferSize.Y - 1 };
        Bonus::Setup();
    }

    void run() override {
        Setup();
        auto lastTime = steady_clock::now();
        while (!isGameOver()) {
            auto currentTime = steady_clock::now();
            auto elapsedTime = duration_cast<milliseconds>(currentTime - lastTime);
            if (elapsedTime.count() >= speed) {
                Input();
                Logic();
                Draw();
                lastTime = currentTime;
            }
            else {
                Input();
            }
        }
        DrawGameOver(); // Show game over message when the game ends
        Sleep(2000); // Wait for 2 seconds before returning to menu
    }
};

void mostrarMenu() {
    cout << "Seleccione la dificultad:\n";
    cout << "1. Facil\n";
    cout << "2. Medio\n";
    cout << "3. Dificil\n";
    cout << "4. Salir\n";
}

int main() {
    int opcion;
    bool continuar = true;

    while (continuar) {
        system("cls"); // Limpiar la pantalla
        mostrarMenu();
        cin >> opcion;

        switch (opcion) {
        case 1: {
            DificultadFacil juego;
            juego.run();
            break;
        }
        case 2: {
            DificultadMedia juego;
            juego.run();
            break;
        }
        case 3: {
            DificultadDificil juego;
            juego.run();
            break;
        }
        case 4:
            continuar = false;
            system("cls"); // Limpiar la pantalla antes de salir
            break;
        default:
            cout << "Opcion invalida.\n";
            break;
        }
    }

    return 0;
}
